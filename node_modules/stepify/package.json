{
  "name": "stepify",
  "description": "Executing nodejs asynchronous tasks by steps chain",
  "version": "0.1.5",
  "engine": {
    "node": ">= 0.8.0"
  },
  "scripts": {
    "test": "mocha -R spec"
  },
  "main": "./index",
  "repository": {
    "type": "git",
    "url": "https://github.com/chemdemo/node-stepify.git"
  },
  "dependencies": {
    "lodash": "~2.3.0"
  },
  "devDependencies": {
    "mocha": "~1.16.2",
    "should": "~2.1.1"
  },
  "keywords": [
    "node-stepify",
    "flow-control",
    "stepify",
    "step",
    "async",
    "asynchronous",
    "chain"
  ],
  "author": {
    "name": "dmyang",
    "email": "yangdemo@gmail.com"
  },
  "maintainers": [
    {
      "name": "dmyang",
      "email": "yangdemo@gmail.com",
      "url": "http://www.dmfeel.com"
    }
  ],
  "license": "MIT",
  "readme": "# stepify\r\n[![Build Status](https://api.travis-ci.org/chemdemo/node-stepify.png)](http://travis-ci.org/chemdemo/node-stepify)\r\n[![NPM version](https://badge.fury.io/js/stepify.png)](https://npmjs.org/package/stepify)\r\n\r\nstepify是一个简单易用的Node.js异步流程控制库，提供一种比较灵活的方式完成Node.js（多）任务。\r\n\r\n目标是将复杂的任务进行拆分成多步完成，使得每一步的执行过程更加透明，化繁为简。\r\n\r\nstepify侧重流程控制，甚至可以和其他异步类库配合使用。\r\n\r\n## stepify特点\r\n\r\n- 最基本的API的就3个：`step()`，`done()`，`run()`，简单容易理解。\r\n\r\n- 精细的粒度划分（同时支持单/多任务），执行顺序可定制化。\r\n\r\n- 每一个异步操作都经过特殊的封装，内部只需要关心这个异步的执行过程。\r\n\r\n- 链式（chain）调用，代码逻辑看起来比较清晰。\r\n\r\n- 灵活的回调函数定制和参数传递。\r\n\r\n- 统一处理单个异步操作的异常，也可根据需要单独处理某个任务的异常。\r\n\r\n## 最简单的用法\r\n\r\n简单实现基于oauth2授权获取用户基本资料的例子：\r\n\r\n``` javascript\r\n// Authorizing based on oauth2 workflow\r\nStepify()\r\n    .step('getCode', function(appId, rUri) {\r\n        var root = this;\r\n        request.get('[authorize_uri]', function(err, res, body) {\r\n            root.done(err, JSON.parse(body).code);\r\n        });\r\n    }, [appId], [redirectUri])\r\n    .step('getToken', function(code) {\r\n        var root = this;\r\n        request.post('[token_uri]', function(err, res, body) {\r\n            root.done(err, JSON.parse(body).access_token);\r\n        });\r\n    })\r\n    .step('getInfo', function(token) {\r\n        request.get('[info_uri]?token=' + token, function(err, res, body) {\r\n            // got user info, pass it to client via http response\r\n        });\r\n    })\r\n    .run();\r\n```\r\n\r\n多个step共用一个handle、静态参数、动态参数传递的例子：\r\n\r\n``` javascript\r\nStepify()\r\n    .step('read', __filename)\r\n    .step(function(buf) {\r\n        // buf is the buffer content of __filename\r\n        var root = this;\r\n        var writed = 'test.js';\r\n\r\n        // do more stuff with buf\r\n        // this demo just replace all spaces simply\r\n        buf = buf.toString().replace(/\\s+/g, '');\r\n        fs.writeFile(writed, buf, function(err) {\r\n            // writed is the name of target file,\r\n            // it will be passed into next step as the first argument\r\n            root.done(err, writed);\r\n        });\r\n    })\r\n    .step('read')\r\n    // `read` here is a common handle stored in workflow\r\n    .read(function(p, encoding) {\r\n        fs.readFile(p, encoding || null, this.done.bind(this));\r\n    })\r\n    .run();\r\n```\r\n\r\n这里多了一个`read()`方法，但read方法并不是stepify内置的方法。实际上，您可以任意“扩展”stepify链！它的奥妙在于`step()`方法的参数，详细请看[step调用说明](#step)。\r\n\r\n可以看到，一个复杂的异步操作，通过stepify定制，每一步都是那么清晰可读！\r\n\r\n## 安装\r\n\r\n``` javascript\r\n$ npm install stepify\r\n```\r\n\r\n## 运行测试\r\n\r\n``` javascript\r\n$ npm install\r\n$ mocha\r\n```\r\n\r\n## 灵活使用\r\n\r\n``` javascript\r\nvar Stepify = require('stepify');\r\nvar workflow1 = Stepify().step(fn).step(fn)...run();\r\n// or\r\nvar workflow2 = new Stepify().step(fn).step(fn)...run();\r\n// or\r\nvar workflow3 = Stepify().step(fn).step(fn);\r\n// do some stuff ...\r\nworkflow3.run();\r\n// or\r\nvar workflow4 = Stepify().task('foo').step(fn).step(fn).task('bar').step(fn).step(fn);\r\n// do some stuff ...\r\nworkflow4.run(['foo', 'bar']);\r\nvar workflow5 = Stepify().step(fn).step(fn);\r\nworkflow5.debug = true;\r\nworkflow5.error = function(err) {};\r\nworkflow5.result = function(result) {};\r\n...\r\nworkflow5.run();\r\n// more ...\r\n```\r\n\r\n注：文档几乎所有的例子都是采用链式调用，但是拆开执行也是没有问题的。\r\n\r\n## 原理\r\n\r\n概念：\r\n\r\n- task：完成一件复杂的事情，可以把它拆分成一系列任务，这些个任务有可能它的执行需要依赖上一个任务的完成结果，它执行的同时也有可能可以和其他一些任务并行，串行并行相结合，这其实跟真实世界是很吻合的。\r\n\r\n- step：每一个task里边可再细分，可以理解成“一步一步完成一个任务（Finish a task step by step）”，正所谓“一步一个脚印”是也。\r\n\r\nstepify内部实际上有两个主要的类，一个是Stepify，一个是Step。\r\n\r\n`Stepify()`的调用会返回一个Stepify实例，在这里称之为workflow，用于调度所有task的执行。\r\n\r\n`step()`的调用会创建一个Step实例，用于完成具体的异步操作（当然也可以是同步操作，不过意义不大），step之间使用简单的api（[done](#done)方法和[next](#next)方法）传递。\r\n\r\n## API 文档\r\n\r\n### Stepify类：\r\n\r\n调用Stepify即可创建一个workflow。\r\n\r\n- [debug](#debug)\r\n\r\n- [task](#task)\r\n\r\n- [step](#step)\r\n\r\n- [pend](#pend)\r\n\r\n- *[stepName](#stepname)*\r\n\r\n- [error](#error)\r\n\r\n- [result](#result)\r\n\r\n- [run](#run)\r\n\r\n### Step类：\r\n\r\nStep类只在Stepify实例调用step方法时创建，不必显式调用。\r\n\r\n- [done](#done)\r\n\r\n- [wrap](#wrap)\r\n\r\n- [fulfill](#fulfill)\r\n\r\n- [vars](#vars)\r\n\r\n- [parallel](#parallel)\r\n\r\n- [jump](#jump)\r\n\r\n- [next](#next)\r\n\r\n- [end](#end)\r\n\r\n---\r\n\r\n#### debug()\r\n\r\n描述：开启debug模式，打印一些log，方便开发。\r\n\r\n调用：debug(flag)\r\n\r\n参数：\r\n\r\n- {Boolean} flag 默认是false\r\n\r\n例子：\r\n\r\n``` javascript\r\nvar work = Stepify().debug(true);\r\n// or\r\nvar work = Stepify();\r\nwork.debug = true;\r\n```\r\n\r\n#### task()\r\n\r\n描述：显式创建一个task，task()的调用是可选的。在新定制一个task时，如果没有显式调用task()，则这个task的第一个step()内部会先生成一个task，后续的step都是挂在这个task上面，每一个task内部会维持自己的step队列。多个task使用[pend](#pend)方法分割。\r\n\r\n调用：task([taskName])\r\n\r\n参数：\r\n\r\n- {String} taskName 可选参数，默认是`_UNAMED_TASK_[index]`。为这个task分配一个名字，如果有多个task实例并且执行顺序需要（使用run()方法）自定义，则设置下taskName方便一点。\r\n\r\n例子：\r\n\r\n``` javascript\r\nvar myWork1 = Stepify().task('foo').step('step1').step('step2').run();\r\n// equal to\r\nvar myWork1 = Stepify().step('step1').step('step2').run();\r\n// multiply tasks\r\nvar myWork2 = Stepify()\r\n\t.task('foo')\r\n    \t.step(fn)\r\n        .step(fn)\r\n    .task('bar')\r\n    \t.step(fn)\r\n        .step(fn)\r\n    .task('baz')\r\n    \t.step(fn)\r\n        .step(fn)\r\n    .run();\r\n```\r\n\r\n#### step()\r\n\r\n描述：定义当前task的一个异步操作，每一次step()调用都会实例化一个Step推入task的step队列。**这个方法是整个lib的核心所在。**\r\n\r\n调用：step(stepName, stepHandle, *args)\r\n\r\n参数：\r\n\r\n- {String} stepName 可选参数，但在不传stepHandle时是必传参数。为这个step分配一个名称。当stepHandle没有传入时，会在Stepify原型上扩展一个以stepName命名的方法，而它具体的实现则在调用stepName方法时决定，这个方法详情请看[*stepName说明*](#stepname)。\r\n\r\n- {Function} stepHandle 可选参数，但在stepName不传时是必传参数。在里边具体定义一个异步操作的过程。stepHandle的执行分两步，先查找这个step所属的task上有没有stepHandle，找不到则查找Stepify实例上有没有stepHandle，再没有就抛异常。\r\n\r\n- {Mix} *args 可选参数，表示这个step的已知参数（即静态参数），在stepHandle执行的时候会把静态参与动态参数（通过[done](#done)或者[next](#next)传入）合并作为stepHandle的最终参数。\r\n\r\n例子：\r\n\r\n- 参数传递\r\n\r\n``` javascript\r\nStepify()\r\n\t.step(function() {\r\n    \tvar root = this;\r\n        setTimeout(function() {\r\n        \t// 这里done的第二个参数（100）即成为下一个stepHandle的动态参数\r\n        \troot.done(null, 100);\r\n        }, 100);\r\n    })\r\n    .step(function(start, n) {\r\n    \t// start === 50\r\n        // n === 100\r\n        var root = this;\r\n        setTimeout(function() {\r\n        \troot.done();\r\n        }, start + n);\r\n    }, 50)\r\n    .run();\r\n```\r\n\r\n- 扩展原型链\r\n\r\n``` javascript\r\nStepify()\r\n    .step('sleep')\r\n    // more step ...\r\n    .step('sleep', 50)\r\n    .sleep(function(start, n) {\r\n        var args = [].slice.call(arguments, 0);\r\n        var root = this;\r\n\r\n        n = args.length ? args.reduce(function(mem, arg) {return mem + arg;}) : 100;\r\n        setTimeout(function() {\r\n            root.done(null, n);\r\n        }, n);\r\n    })\r\n    .run();\r\n```\r\n\r\n#### pend()\r\n\r\n描述：结束一个task的定义，会影响扩展到Stepify原型链上的stepName方法的执行。\r\n\r\n调用：pend()\r\n\r\n参数： 无参数。\r\n\r\n例子：见*[stepName](#stepname)*部分\r\n\r\n#### *stepName()*\r\n\r\n描述：这是一个虚拟方法，它是通过动态扩展Stepify类原型链实现的，具体调用的名称由step方法的`stepName`参数决定。扩展原型链的stepName的必要条件是step方法传了stepName（stepName需要是一个可以通过`.`访问属性的js变量）但是stepHandle没有传，且stepName在原型链上没定义过，当workflow执行结束之后会删除已经扩展到原型链上的所有方法。当调用实例上的stepName方法时，会检测此时有没有在定义的task（使用pend方法结束一个task的定义），如果有则把传入的handle挂到到这个task的handles池里，没有则挂到Stepify的handles池。\r\n\r\n调用：stepName(stepHandle)\r\n\r\n参数：\r\n\r\n- {Function} stepHandle 必传参数，定义stepName对应的stepHandle，可以在多个task之间共享。\r\n\r\n例子：\r\n\r\n- pend()的影响\r\n\r\n``` javascript\r\nStepify()\r\n    .step('mkdir', './foo')\r\n    // 这样定义，在执行到sleep时会抛异常，\r\n    // 因为这个task上面没定义过sleep的具体操作\r\n    .step('sleep', 100)\r\n    .pend()\r\n    .step('sleep', 200)\r\n    .step('mkdir', './bar')\r\n    .sleep(function(n) {\r\n        var root = this;\r\n        setTimeout(function() {\r\n            root.done();\r\n        }, n);\r\n    })\r\n    // 这个pend的调用，使得mkdir方法传入的handle挂在了Stepify handles池中，\r\n    // 所以第一个task调用mkdir方法不会抛异常\r\n    .pend()\r\n    .mkdir(function(p) {\r\n        fs.mkdir(p, this.done.bind(this));\r\n    })\r\n    .run();\r\n```\r\n\r\n- stepHandle的查找\r\n\r\n``` javascript\r\nStepify()\r\n    .step('mkdir', './foo')\r\n    // 定义当前task上的mkdirHandle，这里其实直接.step('mkdir', fn)更清晰\r\n    .mkdir(function(p) {\r\n        fs.mkdir(p, 0755, this.done.bind(this));\r\n    })\r\n    .step('sleep', 100)\r\n    .pend()\r\n    // 这个task上没定义mkdirHandle，会往Stepify类的handles池去找\r\n    .step('mkdir', './bar')\r\n    .step('sleep', 200)\r\n    .pend()\r\n    .sleep(function(n) {\r\n        var root = this;\r\n        setTimeout(function() {\r\n            root.done();\r\n        }, n);\r\n    })\r\n    .mkdir(function(p) {\r\n        fs.mkdir(p, this.done.bind(this));\r\n    })\r\n    .run();\r\n```\r\n\r\n#### error()\r\n\r\n描述：定制task的异常处理函数。\r\n\r\n调用：error(errorHandle)\r\n\r\n参数：\r\n\r\n- {Function} errorHandle 必传参数 **默认会直接抛出异常并中断当前task的执行**。每一个task都可以定制自己的errorHandle，亦可为所有task定制errorHandle。每个step执行如果出错会直接进入这个errorHandle，后面是否继续执行取决于errorHandle内部定义。errorHandle第一个参数便是具体异常信息。\r\n\r\n注意：errorHandle的执行环境是发生异常所在的那个step，也就是说Step类定义的所有方法在errorHandle内部均可用，您可以在异常时决定是否继续执行下一步，或者使用`this.taskName`和`this.name`分别访问所属task的名称和step的名称，进而得到更详细的异常信息。\r\n\r\n例子：\r\n\r\n``` javascript\r\nStepify()\r\n    .step(fn)\r\n    .step(fn)\r\n    // 这个task的异常会走到这里\r\n    .error(function(err) {\r\n        console.error('Error occurs when running task %s\\'s %s step!', this.taskName, this.name);\r\n        if(err.message.match(/can_ignore/)) {\r\n            // 继续执行下一步\r\n            this.next();\r\n        } else {\r\n            throw err;\r\n        }\r\n    })\r\n    .pend()\r\n    .step(fn)\r\n    .step(fn)\r\n    .pend()\r\n    // 所有没显式定义errorHandle的所有task异常都会走到这里\r\n    .error(function(err) {\r\n        console.error(err.stack);\r\n        res.send(500, 'Server error!');\r\n    })\r\n    .run();\r\n```\r\n\r\n#### result()\r\n\r\n描述：所有task执行完之后，输出结果。在Stepify内部，会保存一份结果数组，通过step的[fulfill方法](#fulfill)可以将结果push到这个数组里，result执行的时候将这个数组传入finishHandle。\r\n\r\n调用：result(finishHandle)\r\n\r\n参数：\r\n\r\n- {Function} finishHandle，result本身是可选调用的，如果调用了result，则finishHandle是必传参数。\r\n\r\n例子：\r\n\r\n``` javascript\r\nStepify()\r\n    .step(function() {\r\n        var root = this;\r\n        setTimeout(function() {\r\n            root.fulfill(100);\r\n            root.done(null);\r\n        }, 100);\r\n    })\r\n    .step(function() {\r\n        var root = this;\r\n        fs.readFile(__filename, function(err, buf) {\r\n            if(err) return root.done(err);\r\n            root.fulfill(buf.toString());\r\n            root.done();\r\n        });\r\n    })\r\n    .result(function(r) {\r\n        console.log(r); // [100, fs.readFileSync(__filename).toString()]\r\n    })\r\n    .run();\r\n```\r\n\r\n#### run()\r\n\r\n描述：开始执行所定制的整个workflow。这里比较灵活，执行顺序可自行定制，甚至可以定义一个workflow，分多种模式执行。\r\n\r\n调用：run(*args)\r\n\r\n参数：\r\n\r\n- {Mix} 可选参数，类型可以是字符串（taskName）、数字（task定义的顺序，从0开始）、数组（指定哪些tasks可以并行），也可以混合起来使用（数组不支持嵌套）。默认是按照定义的顺序串行执行所有tasks。\r\n\r\n例子：\r\n\r\n``` javascript\r\nfunction createTask() {\r\n    return Stepify()\r\n        .task('task1')\r\n            .step(function() {\r\n                c1++;\r\n                fs.readdir(__dirname, this.wrap());\r\n            })\r\n            .step('sleep')\r\n            .step('exec', 'cat', __filename)\r\n        .task('task2')\r\n            .step('sleep')\r\n            .step(function() {\r\n                c2++;\r\n                var root = this;\r\n                setTimeout(function() {\r\n                    root.done(null);\r\n                }, 1500);\r\n            })\r\n            .step('exec', 'ls', '-l')\r\n        .task('task3')\r\n            .step('readFile', __filename)\r\n            .step('timer', function() {\r\n                c3++;\r\n                var root = this;\r\n                setTimeout(function() {\r\n                    root.done();\r\n                }, 1000);\r\n            })\r\n            .step('sleep')\r\n            .readFile(function(p) {\r\n                fs.readFile(p, this.done.bind(this));\r\n            })\r\n        .task('task4')\r\n            .step('sleep')\r\n            .step(function(p) {\r\n                c4++;\r\n                fs.readFile(p, this.wrap());\r\n            }, __filename)\r\n        .pend()\r\n        .sleep(function() {\r\n            console.log('Task %s sleep.', this.taskName);\r\n            var root = this;\r\n            setTimeout(function() {\r\n                root.done(null);\r\n            }, 2000);\r\n        })\r\n        .exec(function(cmd, args) {\r\n            cmd = [].slice.call(arguments, 0);\r\n            var root = this;\r\n            exec(cmd.join(' '), this.wrap());\r\n        });\r\n};\r\n\r\nvar modes = {\r\n    'Default(serial)': [], // 10621 ms.\r\n    'Customized-serial': ['task1', 'task3', 'task4', 'task2'], // 10624 ms.\r\n    'Serial-mix-parallel-1': ['task1', ['task3', 'task4'], 'task2'], // 8622 ms.\r\n    'Serial-mix-parallel-2': [['task1', 'task3', 'task4'], 'task2'], // 6570 ms.\r\n    'Serial-mix-parallel-3': [['task1', 'task3'], ['task4', 'task2']], // 6576 ms.\r\n    'All-parallel': [['task1', 'task3', 'task4', 'task2']], // 3552 ms.\r\n    'Part-of': ['task2', 'task4'] // 5526 ms.\r\n};\r\n\r\nvar test = function() {\r\n    var t = Date.now();\r\n    var task;\r\n\r\n    Object.keys(modes).forEach(function(mode) {\r\n        task = createTask();\r\n\r\n        task.result = function() {\r\n            console.log(mode + ' mode finished and took %d ms.', Date.now() - t);\r\n        };\r\n\r\n        task.run.apply(task, modes[mode]);\r\n    });\r\n\r\n    setTimeout(function() {\r\n        log(c1, c2, c3 ,c4); // [6, 7, 6, 7]\r\n    }, 15000);\r\n};\r\n\r\ntest();\r\n```\r\n\r\n---------\r\n\r\n#### done()\r\n\r\n描述：标识完成了一个异步操作（step）。\r\n\r\n调用：done([err, callback, *args])\r\n\r\n参数：\r\n\r\n- {String|Error|null} err 错误描述或Error对象实例。参数遵循Node.js的回调约定，可以不传参数，如果需要传递参数，则第一个参数必须是error对象。\r\n\r\n- {Function} callback 可选参数 自定义回调函数，默认是next，即执行下一步。\r\n\r\n- {Mix} *args 这个参数是传递给callback的参数，也就是作为下一步的动态参数。一般来说是将这一步的执行结果传递给下一步。\r\n\r\n例子：\r\n\r\n``` javascript\r\nStepify()\r\n    .step(function() {\r\n        var root = this;\r\n        setTimeout(function() {\r\n            root.done();\r\n        }, 200);\r\n    })\r\n    .step(function() {\r\n        var root = this;\r\n        exec('curl \"https://github.com/\"', function(err, res) {\r\n            // end this task in error occured\r\n            if(err) root.end();\r\n            else root.done(null, res);\r\n        });\r\n    })\r\n    .step(function(res) {\r\n        var root = this;\r\n        setTimeout(function() {\r\n            // do some stuff with res ...\r\n            console.log(res);\r\n            root.done();\r\n        }, 100);\r\n    })\r\n    .run();\r\n```\r\n\r\n#### wrap()\r\n\r\n描述：其实就是`this.done.bind(this)`的简写，包装done函数保证它的执行环境是当前step。比如原生的`fs.readFile()`的callback的执行环境被设置为null[fs.js#L91](https://github.com/joyent/node/blob/master/lib/fs.js#L91)。\r\n\r\n调用：wrap()\r\n\r\n参数：无\r\n\r\n例子：\r\n\r\n``` javascript\r\nStepify()\r\n    .step(function() {\r\n        fs.readdir(__dirname, this.done.bind(this));\r\n    })\r\n    .step(function() {\r\n        fs.readFile(__filename, this.wrap());\r\n    })\r\n    .run();\r\n```\r\n\r\n#### fulfill()\r\n\r\n描述：把step执行的结果推入结果队列，最终传入finishHandle。最终结果数组的元素顺序在传入给finishHandle时不做任何修改。\r\n\r\n调用：fulfill(*args)\r\n\r\n参数：\r\n\r\n- {Mix} 可选参数 可以是一个或者多个参数，会一一push到结果队列。\r\n\r\n例子：\r\n\r\n``` javascript\r\n// Assuming retrieving user info\r\nStepify()\r\n    .step(function() {\r\n        var root = this;\r\n        db.getBasic(function(err, basic) {\r\n            root.fulfill(basic || null);\r\n            root.done(err, basic.id);\r\n        });\r\n    })\r\n    .step(function(id) {\r\n        var root = this;\r\n        db.getDetail(id, function(err, detail) {\r\n            root.fulfill(detail || null);\r\n            root.done(err);\r\n        });\r\n    })\r\n    .error(function(err) {\r\n        console.error(err);\r\n        res.send(500, 'Get user info error.');\r\n    })\r\n    .result(function(r) {\r\n        res.render('user', {basic: r[0], detail: r[1]});\r\n    })\r\n    .run();\r\n```\r\n\r\n#### vars()\r\n\r\n描述：暂存临时变量，在整个workflow的运行期可用。如果不想在workflow之外使用`var`申明别的变量，可以考虑用vars()。\r\n\r\n调用：vars(key[, value])\r\n\r\n参数：\r\n\r\n- {String} key 变量名。访问临时变量。\r\n\r\n- {Mix} value 变量值。如果只传入key则是访问变量，如果传入两个值则是写入变量并返回这个value。\r\n\r\n例子：\r\n\r\n``` javascript\r\nStepify()\r\n    .step(function() {\r\n        this.vars('foo', 'bar');\r\n        // todo\r\n    })\r\n    .pend()\r\n    .step(function() {\r\n        // todo\r\n        console.log(this.vars('foo')); // bar\r\n    })\r\n    .run();\r\n```\r\n\r\n#### parallel()\r\n\r\n描述：简单的并发支持。*这里还可以考虑引用其他模块（如：[async](https://github.com/caolan/async)）完成并行任务。*\r\n\r\n调用：parallel(arr[, iterator, *args, callback])\r\n\r\n参数：\r\n\r\n- {Array} arr 必传参数。需要并行执行的一个数组，对于数组元素只有一个要求，就是如果有函数则所有元素都必须是一个函数。\r\n\r\n- {Function} iterator 如果arr参数是一个函数数组，这个参数是不用传的，否则是必传参数，它迭代运行arr的每一个元素。iterator的第一个参数是arr中的某一个元素，第二个参数是回调函数（`callback`），当异步执行完之后需要调用`callback(err, data)`。\r\n\r\n- {Mix} \\*args 传递给iterator的参数，在迭代器执行的时候，arr数组的每一个元素作为iterator的第一个参数，\\*args则作为剩下的传入。\r\n\r\n- {Function} callback 可选参数（约定当最后一个参数是函数时认为它是回调函数） 默认是next。这个并行任务的执行结果会作为一个数组按arr中定义的顺序传入callback，如果执行遇到错误，则直接交给errHandle处理。\r\n\r\n例子：\r\n\r\n传入一个非函数数组（parallel(arr, iterator[, *arg, callback])）\r\n\r\n``` javascript\r\nStepify()\r\n    .step(function() {\r\n        fs.readdir(path.resolve('./test'), this.wrap());\r\n    })\r\n    .step(function(list) {\r\n        list = list.filter(function(p) {return path.extname(p).match('js');});\r\n        list.forEach(function(file, i) {list[i] = path.resolve('./test', file);});\r\n        // 注释部分就相当于默认的this.next\r\n        this.parallel(list, fs.readFile, {encoding: 'utf8'}/*, function(bufArr) {this.next(bufArr);}*/);\r\n    })\r\n    .step(function(bufArr) {\r\n        // fs.writeFile('./combiled.js', Buffer.concat(bufArr), this.done.bind(this));\r\n        // or\r\n        this.parallel(bufArr, fs.writeFile.bind(this, './combiled.js'));\r\n    })\r\n    .run();\r\n```\r\n\r\n传入函数数组（parallel(fnArr[])）\r\n\r\n``` javascript\r\nStepify()\r\n    .step(function() {\r\n        this.parallel([\r\n            function(callback) {\r\n                fs.readFile(__filename, callback);\r\n            },\r\n            function(callback) {\r\n                setTimeout(function() {\r\n                    callback(null, 'some string...');\r\n                }, 500);\r\n            }\r\n        ]);\r\n    })\r\n    .step(function(list) {\r\n        console.log(list); // [fs.readFileSync(__filename), 'some string...']\r\n        // todo...\r\n    })\r\n    .run();\r\n```\r\n\r\n下面是一个应用到某项目里的例子：\r\n\r\n``` javascript\r\n...\r\n.step('fetch-images', function() {\r\n    var root = this;\r\n    var localQ = [];\r\n    var remoteQ = [];\r\n\r\n    // do dome stuff to get localQ and remoteQ\r\n\r\n    this.parallel([\r\n        function(callback) {\r\n            root.parallel(localQ, function(frameData, cb) {\r\n                // ...\r\n                db.getContentType(frameData.fileName, function(type) {\r\n                    var imgPath = frameData.fileName + '.' + type;\r\n                    // ...\r\n                    db.fetchByFileName(imgPath).pipe(fs.createWriteStream(targetUrl));\r\n                    cb(null);\r\n                });\r\n            }, function(r) {callback(null, r);});\r\n        },\r\n        function(callback) {\r\n            root.parallel(remoteQ, function(frameData, cb) {\r\n                var prop = frames[frameData['frame']].children[frameData['elem']]['property'];\r\n                // ...\r\n                request({url: prop.src}, function(err, res, body) {\r\n                    // ...\r\n                    cb(null);\r\n                }).pipe(fs.createWriteStream(targetUrl));\r\n            }, function(r) {callback(null, r);});\r\n        },\r\n    ]);\r\n})\r\n...\r\n```\r\n\r\n#### jump()\r\n\r\n描述：在step之间跳转。**这样会打乱step的执行顺序，谨慎使用jump，以免导致死循环**。\r\n\r\n调用：jump(index|stepName)\r\n\r\n参数：\r\n\r\n- {Number} index 要跳转的step索引。在step创建的时候会自建一个索引属性，使用`this._index`可以访问它。\r\n\r\n- {String} stepName step创建时传入的名称。\r\n\r\n例子：\r\n\r\n``` javascript\r\nStepify()\r\n    .step('a', fn)\r\n    .step('b', fn)\r\n    .step(function() {\r\n        if(!this.vars('flag')) {\r\n            this.jump('a');\r\n            this.vars('flag', 1)\r\n        } else {\r\n            this.next();\r\n        }\r\n\r\n        // 其他的异步操作\r\n    })\r\n    .step('c', fn)\r\n    .run();\r\n```\r\n\r\n#### next()\r\n\r\n描述：显式调用下一个step，并将数据传给下一step（即下一个step的动态参数）。其实等同于done(null, *args)。\r\n\r\n调用：next([*args])\r\n\r\n参数：\r\n\r\n- {Mix} *args 可选参数 类型不限，数量不限。\r\n\r\n例子：\r\n\r\n``` javascript\r\nStepify()\r\n    .step(function() {\r\n        // do some stuff ...\r\n        this.next('foo', 'bar');\r\n    })\r\n    .step(function(a, b, c) {\r\n        a.should.equal('test');\r\n        b.should.equal('foo');\r\n        c.should.equal('bar');\r\n    }, 'test')\r\n    .run();\r\n```\r\n\r\n#### end()\r\n\r\n描述：终止当前task的执行。如果遇到异常并传递给end，则直接交给errorHandle，和done一样。不传或者传null则跳出所在task执行下一个task，没有则走到result，没有定义result则退出进程。\r\n\r\n调用：end(err)\r\n\r\n参数：\r\n\r\n- {Error|null} err 可选参数， 默认null。\r\n\r\n例子：\r\n\r\n``` javascript\r\nStepify()\r\n    .step(fn)\r\n    .step(function() {\r\n        if(Math.random() > 0.5) {\r\n            this.end();\r\n        } else {\r\n            // todo ...\r\n        }\r\n    })\r\n    .step(fn)\r\n    .run();\r\n```\r\n\r\n---\r\n\r\n最后，欢迎fork或者[提交bug](https://github.com/chemdemo/node-stepify/issues)。\r\n\r\n## License\r\n\r\nMIT [http://rem.mit-license.org](http://rem.mit-license.org)\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/chemdemo/node-stepify/issues"
  },
  "homepage": "https://github.com/chemdemo/node-stepify",
  "_id": "stepify@0.1.5",
  "_from": "Stepify@"
}
